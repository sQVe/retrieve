jest.mock('../src/utility', () => {
  const utility = require.requireActual('../src/utility')

  return { ...utility, urlGuard: jest.fn(utility.urlGuard) }
})
Object.defineProperty(global, 'log', { value: jest.fn(), writable: true })

import { Response } from 'node-fetch'

import Righttp from '../src/index'
import { createApi, resetApi } from './setup/api'
import { items } from './setup/db.json'
import { urlGuard } from '../src/utility'

const noop = () => {}

describe('Righttp', () => {
  beforeEach(() => {
    createApi()
  })

  afterEach(() => {
    resetApi()
  })

  it('should be instantiated', () => {
    const http = new Righttp()

    expect(http).toBeInstanceOf(Righttp)
    expect(http).toBeDefined()
    expect(http.url).toBeDefined()
    expect(http.init).toBeDefined()
    expect(http.opts).toBeDefined()
  })

  it('should set url with urlGuard', () => {
    new Righttp('api') // eslint-disable-line no-new

    expect(urlGuard).toHaveBeenCalledTimes(1)
  })

  it('should set defaults for init', () => {
    const http = new Righttp()

    expect(http.init).toMatchSnapshot()
  })

  it('should shallow merge init', () => {
    const http = new Righttp('api', { headers: { Authentication: 'foo' } })

    expect(http.init).toMatchSnapshot()
  })

  it('should set defaults for opts', () => {
    const http = new Righttp()

    expect(http.opts).toMatchSnapshot()
  })

  it('should shallow merge opts', () => {
    const http = new Righttp('api', null, { responseAs: 'response' })

    expect(http.opts).toMatchSnapshot()
  })

  it('should bind context', () => {
    const http = new Righttp()

    expect(Object.keys(http)).toMatchSnapshot()
  })

  it('should not bind context', () => {
    const http = new Righttp('', {}, { bindContext: false })

    expect(Object.keys(http)).toMatchSnapshot()
  })

  describe('constructInit', () => {
    const http = new Righttp('', {
      headers: () => ({ Accept: true }),
      method: () => true,
      responseAs: true,
    })

    it('should return value on key', () => {
      expect(http.constructInit('responseAs')).toBe(true)
    })

    it('should call functions and set return as value', () => {
      expect(http.constructInit('method')).toBe(true)
    })

    it('should construct init recusively', () => {
      expect(http.constructInit()).toEqual({
        headers: { Accept: true },
        method: true,
        responseAs: true,
      })
    })
  })

  describe('currentContentType', () => {
    it('should return the currently set content type', () => {
      const http = new Righttp('', { headers: { 'Content-Type': true } })

      expect(http.currentContentType()).toBe(true)
    })
  })

  describe('forwardToStatusListener', () => {
    it('should handle no status listeners', async () => {
      const http = new Righttp('api/200', null, { onStatus: undefined })
      const res = await http.request()

      expect(res).toBe(undefined)
    })

    it('should call correct status listener', async () => {
      const statusListenerMock = jest.fn()
      const http = new Righttp('api/404', null, {
        onStatus: { 404: statusListenerMock },
      })

      await http.request().catch(noop)

      expect(statusListenerMock).toHaveBeenCalled()
    })

    it('should call correct status listener within range', async () => {
      const statusListenerMock = jest.fn()
      const http = new Righttp('api/404', null, {
        onStatus: { '400-500': statusListenerMock },
      })

      await http.request().catch(noop)

      expect(statusListenerMock).toHaveBeenCalled()
    })
  })

  describe('parseRequest', () => {
    it('should leave response untouched', async () => {
      const http = new Righttp('', null, {
        responseAs: null,
      })

      expect(await http.parseResponse(new Response())).toBeInstanceOf(Response)
    })

    it('should leave response untouched', async () => {
      const http = new Righttp('', null, {
        responseAs: 'response',
      })
      const res = await http.parseResponse(new Response())

      expect(res).toBeInstanceOf(Response)
    })

    it('should parse json', async () => {
      const http = new Righttp('api/items/0', { method: 'GET' })
      const res = await http.request()

      expect(res).toEqual(items[0])
    })

    it('should throw when parsing json', async () => {
      const http = new Righttp()
      const res = http.parseResponse(new Response(']'))

      await expect(res).rejects.toThrowError(SyntaxError)
    })

    it('should handle empty response when parsing json', async () => {
      const http = new Righttp('api/items/0', { method: 'DELETE' })
      const res = await http.request()

      expect(res).toEqual(undefined)
    })

    ;['arrayBuffer', 'blob', 'text'].forEach(f => {
      // NOTE: `formData` is excluded because it is not supported by
      // `node-fetch`. Once, or if, this changes we should include it.
      it(`should parse ${f}`, async () => {
        const http = new Righttp('', null, { responseAs: f })
        const res = new Response()
        jest.spyOn(res, f)

        await http.parseResponse(res)

        expect(res[f]).toHaveBeenCalledTimes(1)
      })
    })
  })

  describe('preparePayload', () => {
    const payload = { foo: true, bar: true }

    it('should return JSON payload', () => {
      const http = new Righttp('', {})

      expect(http.preparePayload(payload)).toBe(JSON.stringify(payload))
    })

    it('should return query string payload', () => {
      const http = new Righttp('', {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      })

      expect(http.preparePayload(payload)).toBe('foo=true&bar=true')
    })

    it('should return FormData payload', () => {
      const http = new Righttp('', {
        headers: { 'Content-Type': 'multipart/form-data' },
      })
      const formData = new FormData()
      formData.append('foo', true)
      formData.append('bar', true)

      expect(http.preparePayload(payload)).toEqual(formData)
    })

    it('should return raw payload', () => {
      const http = new Righttp('', {
        headers: { 'Content-Type': 'foo' },
      })

      expect(http.preparePayload(payload)).toEqual(payload)
    })

    it('should return raw payload', () => {
      const http = new Righttp('', {}, { rawPayload: true })

      expect(http.preparePayload(payload)).toEqual(payload)
    })
  })

  describe('request', () => {
    it('should apply defaults', () => {
      const http = new Righttp('api/', { foo: true })
      jest.spyOn(http, 'applyDefaults')

      http.request('items/', { bar: true })

      expect(http.applyDefaults).toHaveBeenCalledTimes(1)
      expect(http.applyDefaults).toHaveBeenCalledWith('items/', { bar: true })
      expect(http.applyDefaults.mock.results[0]).toMatchSnapshot()
    })

    it('should throw', async () => {
      const http = new Righttp('')

      await expect(http.request()).rejects.toThrowError(
        new Error('Righttp needs an URL to make an request')
      )
    })

    it('should forward to status listener', async () => {
      const http = new Righttp('api/', null, { responseAs: 'response' })
      jest.spyOn(http, 'forwardToStatusListener')

      const res = await http.request('items/')

      expect(http.forwardToStatusListener).toHaveBeenCalledTimes(1)
      expect(http.forwardToStatusListener).toHaveBeenCalledWith(res)
    })

    it('should parse response', async () => {
      const http = new Righttp('api/', null, { responseAs: 'response' })
      jest.spyOn(http, 'parseResponse')

      const res = await http.request('items/')

      expect(http.parseResponse).toHaveBeenCalledTimes(1)
      expect(http.parseResponse).toHaveBeenCalledWith(res)
    })

    it('should throw', async () => {
      const http = new Righttp('api/', null, { responseAs: 'response' })

      await expect(http.request('404/')).rejects.toMatchSnapshot()
    })
  })
})
